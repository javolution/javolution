/*
 * Javolution - Java(TM) Solution for Real-Time and Embedded Systems
 * Copyright (C) 2004 - The Javolution Team (http://javolution.org/)
 * 
 * Permission to use, copy, modify, and distribute this software is
 * freely granted, provided that this notice is preserved.
 */
package javolution.xml.sax;

import j2me.nio.ByteBuffer;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

import javolution.JavolutionError;
import javolution.io.Utf8ByteBufferReader;
import javolution.io.Utf8StreamReader;
import javolution.lang.Reusable;
import javolution.lang.TypeFormat;

import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;

/**
 * <p> This class provides a real-time SAX2-like XML parser; this parser is
 *     <i>extremely</i> fast and <b>does not create temporary objects</b>
 *     (no garbage generated and no GC interruption).</p>
 * <p> The parser input source can be either a {@link #parse(Reader) Reader},
 *     an {@link #parse(InputStream) InputStream} or even a {@link 
 *     #parse(ByteBuffer) ByteBuffer} (e.g. <code>MappedByteBuffer</code>).</p>
 * <p> This parser is light (less than 15Kbytes compressed) and maintains
 *     a very small memory footprint while parsing (e.g. less than 16Kbytes
 *     while parsing 32Mbytes files). Typical applications include SOAP
 *     messaging, embedded/realtime systems, web servers (possibly thousands
 *     instances running concurrently), etc.</p>
 * <p> Namespaces (SAX2 feature), comments, predefined entities
 *     (<code>&amp;amp;, &amp;lt;, &amp;gt;, &amp;apos;, &amp;quot;</code>)
 *     numeric character references (e.g. <code>&amp;#10;</code> for
 *     linefeed) and <code>CDATA</code> are recognized. Processing instructions,
 *     comments and entities declarations are ignored.</p>
 * <p> The <code>CharSequence</code> generated by this parser have
 *     the following characteristics:
 *     <ul>
 *         <li> They are immutable within their definition scope. The <code>
 *              CharSequence</code> created while parsing an XML element are
 *              reused only after the element is out-of-scope. In other words,
 *              when the <code>endElement</code> method is called, all
 *              attributes specified by <code>startElement</code> are still
 *              intact.</li>
 *         <li> They support equality or lexical comparison with any
 *              <code>CharSequence</code> (e.g. <code>String</code>).</li>
 *         <li> They have the same hashcode than <code>String</code> and can be
 *              used to retrieve data from a <code>Map</code> (e.g.
 *              {@link javolution.util.FastMap FastMap}) for which 
 *              the keys are <code>String</code> instances.</li>
 *         <li> Like any <code>CharSequence</code>, they can be parsed
 *              to primitive types (e.g. int, double) using the utility class
 *              {@link TypeFormat}.</li>
 *     </ul></p>
 * <p> Finally, this parser does not break up character data during call back
 *     (the whole character data between markups is always being returned).
 *     During parsing, no memory allocation is ever performed unless the
 *     data buffer capacity (see {@link #RealtimeParser(int)}) is too
 *     small to hold the whole character data. In which case, the internal data
 *     buffer is automatically re-sized.</p>
 *
 * <p><i> Note: This parser is a <b>SAX2-like</b> parser with the
 *        <code>j2me.lang.String</code> type replaced by the more generic 
 *       <code>j2me.lang.CharSequence</code> in {@link ContentHandler},
 *       {@link Attributes} interfaces and {@link DefaultHandler} base classes.
 *       If a standard SAX2 or JAXP parser is required, you may consider using
 *       the wrapping class {@link XMLReaderImpl}. Fast but not as fast as 
 *       <code>j2me.lang.String</code> instances are dynamically allocated
 *       while parsing.</i></p>
 *
 * @author  <a href="mailto:jean-marie@dautelle.com">Jean-Marie Dautelle</a>
 * @version 4.6, June 11, 2003
 */
public final class RealtimeParser implements Reusable {

    /**
     * Holds the default handler instance.
     */
    private static DefaultHandler DEFAULT_HANDLER = new DefaultHandler();

    /**
     * Holds the content handler.
     */
    private ContentHandler _contentHandler;

    /**
     * Holds the error handler.
     */
    private ErrorHandler _errorHandler;

    /**
     * Holds the parsing line.
     */
    private int _lineNumber;

    /**
     * Holds the column offset (column = _columnOffset + _index).
     */
    private int _columnOffset;

    /**
     * Holds the character buffer used for reading.
     */
    private final char[] _chars;

    /**
     * Holds the default stream reader (UTF-8).
     */
    private final Utf8StreamReader _inputStreamReader;

    /**
     * Holds the default ByteBuffer reader (UTF-8).
     */
    private final Utf8ByteBufferReader _byteBufferReader;

    /**
     * Holds the current index in the character buffer.
     */
    private int _index;

    /**
     * Holds the data buffer for CharSequence produced by this parser.
     */
    private char[] _data;

    /**
     * Holds the current length of the data buffer (_data).
     */
    private int _length;

    /**
     * Holds the CharSequence pool.
     */
    private CharSequenceImpl[] _pool;

    /**
     * Holds the current pool index.
     */
    private int _poolIndex;

    /**
     * Holds the current attributes.
     */
    final AttributesImpl _attributes = new AttributesImpl();

    /**
     * Holds the current default namespace.
     */
    private final Namespace _namespace = new Namespace();

    /**
     * Holds the document locator.
     */
    private final LocatorImpl _locator = new LocatorImpl();

    /**
     * Creates a real time parser with an initial data buffer capacity of
     * <code>2048</code> characters.
     */
    public RealtimeParser() {
        this(2048);
    }

    /**
     * Creates a real-time parser of specified initial data buffer capacity.
     * 
     * @param capacity the data buffer initial capacity (in characters).
     */
    public RealtimeParser(int capacity) {

        // Sets CharSequence pool.
        _pool = new CharSequenceImpl[256];
        for (int i=0; i < _pool.length; i++) {
            _pool[i] = new CharSequenceImpl();
        }

        // Sizes buffers, data buffer length must be greater or equal to
        // reader capacity to avoid overflow.
        _chars = new char[capacity];
        _data = new char[capacity + _chars.length];
        _inputStreamReader = new Utf8StreamReader(capacity);
        _byteBufferReader = new Utf8ByteBufferReader();

        // Sets default handlers.
        setContentHandler(DEFAULT_HANDLER);
        setErrorHandler(DEFAULT_HANDLER);
    }

    /**
     * Allows an application to register a real-time content event handler.
     *
     * <p> If the application does not register a content handler, all
     *     content events reported by the SAX parser will be silently
     *     ignored.</p>
     *
     * <p> Applications may register a new or different handler in the
     *     middle of a parse, and the SAX parser must begin using the new
     *     handler immediately.</p>
     *
     * @param  handler the real-time content handler.
     * @throws NullPointerException if the handler argument is null.
     * @see    #getContentHandler
     */
    public void setContentHandler(ContentHandler handler) {
        if (handler != null) {
            _contentHandler = handler;
            _namespace.setContentHandler(handler);
        } else {
            throw new NullPointerException();
        }
    }

    /**
     * Returns the current real-time content handler.
     *
     * @return the current real-time content handler, or <code>null</code>
     *         if none has been registered.
     * @see    #setContentHandler
     */
    public ContentHandler getContentHandler() {
        return (_contentHandler == DEFAULT_HANDLER) ? null : _contentHandler;
    }

    /**
     * Allows an application to register an error event handler.
     *
     * <p> If the application does not register an error handler, all
     *     error events reported by the SAX parser will be silently
     *     ignored; however, normal processing may not continue.  It is
     *     highly recommended that all SAX applications implement an
     *     error handler to avoid unexpected bugs.</p>
     *
     * <p> Applications may register a new or different handler in the
     *     middle of a parse, and the SAX parser must begin using the new
     *     handler immediately.</p>
     *
     * @param  handler the error handler.
     * @throws NullPointerException if the handler argument is null.
     * @see    #getErrorHandler
     */
    public void setErrorHandler(ErrorHandler handler) {
        if (handler != null) {
            _errorHandler = handler;
        } else {
            throw new NullPointerException();
        }
    }

    /**
     * Returns the current error handler.
     *
     * @return the current error handler, or <code>null</code> if none
     *         has been registered.
     * @see    #setErrorHandler
     */
    public ErrorHandler getErrorHandler() {
        return (_errorHandler == DEFAULT_HANDLER) ? null : _errorHandler;
    }

    /**
     * Parses an XML document from the specified input stream (UTF-8 encoding).
     *
     * @param in the input stream with UTF-8 encoding.
     * @throws org.xml.sax.SAXException any SAX exception, possibly
     *         wrapping another exception.
     * @throws j2me.io.IOException an IO exception from the parser,
     *         possibly from a byte stream or character stream
     *         supplied by the application.
     * @see    Utf8StreamReader
     */
    public void parse(InputStream in) throws IOException, SAXException {
        _inputStreamReader.setInputStream(in);
        parse(_inputStreamReader);
    }

    /**
     * Parses an XML document from the specified <code>ByteBuffer</code>
     * (UTF-8 encoding).
     *
     * @param  byteBuffer the byte buffer with UTF-8 encoding.
     * @throws org.xml.sax.SAXException any SAX exception, possibly
     *         wrapping another exception.
     * @throws j2me.io.IOException an IO exception from the parser,
     *         possibly from a byte stream or character stream
     *         supplied by the application.
     * @see    Utf8ByteBufferReader
     */
    public void parse(ByteBuffer byteBuffer) throws IOException, SAXException {
        _byteBufferReader.setByteBuffer(byteBuffer);
        parse(_byteBufferReader);
    }

    /**
     * Parses an XML document using the specified reader.
     *
     * @param  reader the document reader.
     * @throws SAXException any SAX exception, possibly wrapping another
     *         exception.
     * @throws IOException an IO exception from the parser, possibly from
     *         a byte stream or character stream supplied by the application.
     */
    public void parse(Reader reader) throws IOException, SAXException {

        // Checks that this parser is not currently parsing.
        if (_isParsing) {
            throw new SAXException("Currently parsing");
        }

        // Sets locator.
        _isParsing = true;
        _lineNumber = 1;
        _columnOffset = 1; // column = _columnOffset + _index
        _contentHandler.setDocumentLocator(_locator);

        try {
            _contentHandler.startDocument();
            parseContent(reader);
        } finally { // Always executed.
            _contentHandler.endDocument();
            reader.close();

            // Resets local variable.
            _index = 0;
            _length = 0;
            _attributes.clear();
            _namespace.reset();
            _poolIndex = 0;
            _elemPrefix = null;
            _attrPrefix = null;
            _isParsing = false; // Done.
        }
    }
    private boolean _isParsing;

    /**
     * Parses the content of the document.
     *
     * @param reader the stream reader.
     * @throws SAXException any SAX exception, possibly wrapping another
     *         exception.
     * @throws IOException an IO exception from the parser, possibly from
     *         a byte stream or character stream supplied by the application.
     */
    private void parseContent(Reader reader) throws IOException, SAXException {

        int start = 0; // Start index of the data being processed.
        int state = CHAR_DATA;
        int savedState =0 ; // Saved state (escape processing)
        int escStart = 0; // The starting point of an escape sequence.
        for (int j = reader.read(_chars, 0, _chars.length); _index < j;) {

            // Preprocessing.
            //
            char c = _chars[_index];
            if (++_index == j) { // Reloads buffer.
                _columnOffset += _index;
                _index = 0;
                j = reader.read(_chars, 0, _chars.length);
                if ((_length + j) >= _data.length) {
                    // Potential overflow, resizes.
                    char[] tmp = new char[_length + j + _data.length];
                    System.arraycopy(_data, 0, tmp, 0, _length);
                    _data = tmp;
                }
            }
            // Replaces #xD and #xD#xA with #xA as per XML 1.0
            // recommendations (&2.11).
            if (c < 0x20) {
                if (c == 0xD) { // Replaces #xD with #xA
                    if ((_index < j) && (_chars[_index] == 0xA)) {
                        // Unless next char is #xA, then continue,
                        // #xD#xA will be replaced by #xA
                        continue;
                    }
                    c = 0xA;
                }
                if (c == 0xA) {
                    _lineNumber++; // Do it now, locator will readjust.
                    _lineLength = _columnOffset + _index;
                    _columnOffset = -_index;  // column = 0
                } else if (c != 0x9) { // Not a tab.
                    parseError(
                        "Illegal XML character U+" + Integer.toHexString(c));
                }
            }
            // Appends to buffer.
            _data[_length++] = c;
            // Detects escape sequence (e.g. character reference).
            if (  (c == '&') && (state != COMMENT) && (state != PI) &&
                  (state != CDATA) && (state != ESCAPE) ) { // (&2.4)
                savedState = state;
                escStart = _length;
                state = ESCAPE;
            }

            // Main processing.
            //
            switch (state) {
            case CHAR_DATA:
                if (c == '<') {
                    int nbrChar = _length - start - 1;
                    if (nbrChar > 0) {
                        _contentHandler.characters(_data, start, nbrChar);
                    }
                    state = MARKUP;
                    _length = start; // No need to keep character data.
                }
                break;

            case MARKUP:
                if (_length - start == 1) {
                    if (c == '/') {
                        state = END_TAG + READ_ELEM_NAME;
                        _length = start;
                        _elemQName = newChars();
                        _elemQName.first = start;
                    } else if (c == '?') {
                        state = PI;
                        _length = start;
                    } else if (c != '!') {
                        state = START_TAG + READ_ELEM_NAME;
                        _elemQName = newChars();
                        _elemQName.first = start;
                    }
                } else if ((_length - start == 3) && (_data[start]   == '!') &&
                                                    (_data[start+1] == '-') &&
                                                    (_data[start+2] == '-')) {
                    state = COMMENT;
                    _length = start;
                } else if ((_length - start == 8) && (_data[start] == '!') &&
                                                    (_data[start+1] == '[') &&
                                                    (_data[start+2] == 'C') &&
                                                    (_data[start+3] == 'D') &&
                                                    (_data[start+4] == 'A') &&
                                                    (_data[start+5] == 'T') &&
                                                    (_data[start+6] == 'A') &&
                                                    (_data[start+7] == '[') ) {
                    state = CDATA;
                    _length = start;
                } else if (c == '>') {
                    state = CHAR_DATA;
                    _length = start;
                }
                break;

            case COMMENT:
                if (    (c == '>') && (_length - start >= 3) &&
                        (_data[_length-2] == '-') &&
                        (_data[_length-3] == '-')) {
                    state = CHAR_DATA;
                    _length = start; // No need to keep comments in buffer.
                }
                break;

            case PI: // Ignores Processing Instructions.
                if (    (c == '>') && (_length - start >= 2) &&
                        (_data[_length-2] == '?')) {
                    state = CHAR_DATA;
                    _length = start;
                }
                break;

            case CDATA:
                if (    (c == '>') && (_length - start >= 3) &&
                        (_data[_length-2] == ']') &&
                        (_data[_length-3] == ']')) {
                    _contentHandler.characters(
                        _data, start, _length - start - 3);
                    state = CHAR_DATA;
                    _length = start; // No need to keep character data.
                }
                break;


            // START_TAG:
                    case START_TAG + READ_ELEM_NAME:
                        if (c == '>') {
                            _elemQName.length = _length - _elemQName.first - 1;
                            _elemQName.data = _data;
                            processElement(state);
                            state = CHAR_DATA;
                            start = _length;
                        } else if (c == '/') {
                            _elemQName.length = _length - _elemQName.first - 1;
                            _elemQName.data = _data;
                            state = EMPTY_TAG;
                        } else if ((c == ':') && (_elemPrefix == null)) {
                            _elemPrefix = newChars();
                            _elemPrefix.first = _elemQName.first;
                            _elemPrefix.length = _length - _elemQName.first - 1;
                            _elemPrefix.data = _data;
                        } else if (c <= ' ') {
                            _elemQName.length = _length - _elemQName.first - 1;
                            _elemQName.data = _data;
                            state = START_TAG + ELEM_NAME_READ;
                        }
                        break;
                    case START_TAG + ELEM_NAME_READ:
                        if (c == '>') {
                            processElement(state);
                            state = CHAR_DATA;
                            start = _length;
                        } else if (c == '/') {
                            state = EMPTY_TAG;
                        } else if (c > ' ') {
                            _attrQName = newChars();
                            _attrQName.first = _length - 1;
                            state = START_TAG + READ_ATTR_NAME;
                        }
                        break;
                    case START_TAG + READ_ATTR_NAME:
                        if (c <= ' ') {
                            _attrQName.length = _length - _attrQName.first - 1;
                            _attrQName.data = _data;
                            state = START_TAG + ATTR_NAME_READ;
                        } else if (c == '=') {
                            _attrQName.length = _length - _attrQName.first - 1;
                            _attrQName.data = _data;
                            state = START_TAG + EQUAL_READ;
                        } else if ((c == ':') && (_attrPrefix == null)){
                            _attrPrefix = newChars();
                            _attrPrefix.first = _attrQName.first;
                            _attrPrefix.length = _length - _attrQName.first - 1;
                            _attrPrefix.data = _data;
                        }
                        break;
                    case START_TAG + ATTR_NAME_READ:
                        if (c == '=') {
                            state = START_TAG + EQUAL_READ;
                        } else if (c > ' ') {
                            parseError("'=' expected");
                        }
                        break;
                    case START_TAG + EQUAL_READ:
                        if (c == '\'') {
                            _attrValue = newChars();
                            _attrValue.first = _length;
                            state = START_TAG + READ_ATTR_VALUE_SIMPLE_QUOTE;
                        } else if (c == '\"') {
                            _attrValue = newChars();
                            _attrValue.first = _length;
                            state = START_TAG + READ_ATTR_VALUE_DOUBLE_QUOTE;
                        } else if (c > ' ') {
                            parseError("Quotes expected");
                        }
                        break;
                    case START_TAG + READ_ATTR_VALUE_SIMPLE_QUOTE:
                        if (c == '\'') {
                            _attrValue.length = _length - _attrValue.first - 1;
                            _attrValue.data = _data;
                            processAttribute();
                            state = START_TAG + ELEM_NAME_READ;
                        }
                        break;
                    case START_TAG + READ_ATTR_VALUE_DOUBLE_QUOTE:
                        if (c == '\"') {
                            _attrValue.length = _length - _attrValue.first - 1;
                            _attrValue.data = _data;
                            processAttribute();
                            state = START_TAG + ELEM_NAME_READ;
                        }
                        break;

            // END_TAG:
                    case END_TAG + READ_ELEM_NAME:
                        if (c == '>') {
                            _elemQName.length = _length - _elemQName.first - 1;
                            _elemQName.data = _data;
                            processElement(state);
                            state = CHAR_DATA;
                            start = _length;
                        } else if ((c == ':') && (_elemPrefix == null)) {
                            _elemPrefix = newChars();
                            _elemPrefix.first = _elemQName.first;
                            _elemPrefix.length = _length - _elemQName.first - 1;
                            _elemPrefix.data = _data;
                        } else if (c <= ' ') {
                            _elemQName.length = _length - _elemQName.first - 1;
                            _elemQName.data = _data;
                            state = END_TAG + ELEM_NAME_READ;
                        }
                        break;
                    case END_TAG + ELEM_NAME_READ:
                        if (c == '>') {
                            processElement(state);
                            state = CHAR_DATA;
                            start = _length;
                        } else if (c > ' ') {
                            parseError("'>' expected");
                        }
                        break;

            case EMPTY_TAG:
                if (c == '>')  {
                    processElement(state);
                    state = CHAR_DATA;
                    start = _length;
                } else {
                    parseError("'>' expected");
                }
                break;

            case ESCAPE:
                if (c == ';') { // Escape terminator.
                    if (    (_length - escStart == 3) &&
                            (_data[_length-3] == 'l') &&
                            (_data[_length-2] == 't') ) {
                        _data[escStart-1] = '<';
                    } else if ((_length - escStart == 3) &&
                               (_data[_length-3] == 'g') &&
                               (_data[_length-2] == 't')) {
                        _data[escStart-1] = '>';
                    } else if ((_length - escStart == 5) &&
                               (_data[_length-5] == 'a') &&
                               (_data[_length-4] == 'p') &&
                               (_data[_length-3] == 'o') &&
                               (_data[_length-2] == 's')) {
                        _data[escStart-1] = '\'';
                    } else if ((_length - escStart == 5) &&
                               (_data[_length-5] == 'q') &&
                               (_data[_length-4] == 'u') &&
                               (_data[_length-3] == 'o') &&
                               (_data[_length-2] == 't')) {
                        _data[escStart-1] = '\"';
                    } else if ((_length - escStart == 4) &&
                               (_data[_length-4] == 'a') &&
                               (_data[_length-3] == 'm') &&
                               (_data[_length-2] == 'p')) {
                        _data[escStart-1] = '&';
                    } else { // Character reference (&4.1)
                        if ((_length - escStart > 1) && (_data[escStart] == '#')) {
                            try {
                                if (_data[escStart+1] == 'x') { // Hexadecimal.
                                    _num.first = escStart + 2;
                                    _num.length = _length - escStart - 3;
                                    _num.data = _data;
                                    _data[escStart - 1]
                                        = (char) TypeFormat.parseInt(_num, 16);
                                } else { // Decimal.
                                    _num.first = escStart + 1;
                                    _num.length = _length - escStart - 2;
                                    _num.data = _data;
                                    _data[escStart - 1]
                                        = (char) TypeFormat.parseInt(_num);
                                }
                            } catch (NumberFormatException e) {
                                parseError("Ill-formed character reference");
                            }
                        } else {
                            parseError("'#' expected");
                        }
                    }
                    state = savedState;
                    _length = escStart;
                } else if (c <= ' ') {
                    parseError("';' expected");
                }
                break;

            default:
                throw new JavolutionError("State unknown: " + state);
            }
        }
    }
    private int _lineLength; // Used by locator when line break occurs.
    private CharSequenceImpl _elemQName;
    private CharSequenceImpl _elemPrefix;
    private CharSequenceImpl _attrQName;
    private CharSequenceImpl _attrPrefix;
    private CharSequenceImpl _attrValue;
    private CharSequenceImpl _num  = new CharSequenceImpl();

    // Defines parsing states.
    private static final int CHAR_DATA = 0x10;
    private static final int MARKUP    = 0x20;
    private static final int COMMENT   = 0x30;
    private static final int PI        = 0x40;
    private static final int CDATA     = 0x50;
    private static final int START_TAG = 0x60;
    private static final int END_TAG   = 0x70;
    private static final int EMPTY_TAG = 0x80;
    private static final int ESCAPE    = 0x90;
    // Defines element parsing sub-states.
    private static final int READ_ELEM_NAME = 0x01;
    private static final int ELEM_NAME_READ = 0x02;
    private static final int READ_ATTR_NAME = 0x03;
    private static final int ATTR_NAME_READ = 0x04;
    private static final int EQUAL_READ     = 0x05;
    private static final int READ_ATTR_VALUE_SIMPLE_QUOTE = 0x06;
    private static final int READ_ATTR_VALUE_DOUBLE_QUOTE = 0x07;

    /**
     * Processes the attribute just read.
     *
     * @throws SAXException any SAX exception, possibly wrapping another
     *         exception.
     */
    private void processAttribute() throws SAXException {
        if (_attrPrefix == null) { // No prefix.
            if (isXmlns(_attrQName)) {  // Sets default namespace.
                _namespace.map(CharSequenceImpl.EMPTY, _attrValue);
            } else {
                _attributes.add(
                    CharSequenceImpl.EMPTY, // URI
                    _attrQName, // Local Name.
                    _attrQName, // Qualified Name.
                    _attrValue); 
            }
        } else { // Prefix.
            CharSequenceImpl localName = newChars();
            localName.first = _attrQName.first + _attrPrefix.length + 1;
            localName.length = _attrQName.length - _attrPrefix.length - 1;
            localName.data = _attrQName.data;

            if (isXmlns(_attrPrefix)) { // Namespace association.
                _namespace.map(localName, _attrValue);
            } else { // Searches URI
                CharSequenceImpl  uri = _namespace.getUri(_attrPrefix);
                if (uri != null) {
                    _attributes.add(
                        uri, // URI
                        localName, // Local Name.
                        _attrQName, // Qualified Name.
                        _attrValue); // TextBuilder.
                }  else {
                    parseError("Namespace " + _attrPrefix + " undefined");
                }
            }
            _attrPrefix = null; // Resets.
        }
    }

    /**
     * Processes the element just read.
     *
     * @param  state the current parser state.
     * @throws SAXException any SAX exception, possibly wrapping another
     *         exception.
     */
    private void processElement(int state) throws SAXException {
        CharSequenceImpl uri;
        CharSequenceImpl localName;
        if (_elemPrefix != null) { // Prefix, sets uri.
            localName = newChars();
            localName.first = _elemQName.first + _elemPrefix.length + 1;
            localName.length = _elemQName.length - _elemPrefix.length - 1;
            localName.data = _elemQName.data;
            uri = _namespace.getUri(_elemPrefix);
            if (uri == null) {
                parseError("Namespace " + _elemPrefix + " undefined");
            }
            _elemPrefix = null; // Resets.
        } else { // No prefix.
            localName = _elemQName;
            uri = _namespace.getDefault();
        }
        if ((state & 0xF0) == START_TAG) {
            _namespace.push(_elemQName);
            _contentHandler.startElement(
                uri, localName, _elemQName, _attributes);
            _attributes.clear();
        } else {
            CharSequenceImpl startElemName;
            if ((state & 0xF0) == END_TAG) {
                startElemName = _namespace.pop();
                if (!_elemQName.equals(startElemName)) {
                    parseError("Expected end tag for " + startElemName);
                }
            } else if (state == EMPTY_TAG) {
                startElemName = _elemQName;
                _contentHandler.startElement(
                    uri, localName, _elemQName, _attributes);
               _attributes.clear();
            } else {
                throw new JavolutionError("Unexpected state: " + state);
            }
            _contentHandler.endElement(uri, localName, _elemQName);

            // Reuses objects/data local to the element terminated.
            _length = startElemName.first;
            while (_pool[--_poolIndex] != startElemName) {}
        }
    }

    /**
     * Looks up the value of a feature.
     *
     *  <p> Recognizes <code>http://xml.org/sax/features/namespaces</code>
     *      and the  <code>http://xml.org/sax/features/namespace-prefixes</code>
     *      feature names.</p>
     *
     * @param  name the feature name, which is a fully-qualified URI.
     * @return the current state of the feature (true or false).
     * @throws org.xml.sax.SAXNotRecognizedException when the XMLReader does
     *         not recognize the feature name.
     * @throws org.xml.sax.SAXNotSupportedException when the XMLReader
     *         recognizes the feature name but cannot determine its value
     *         at this time.
     * @see #setFeature
     */
    public boolean getFeature(String name) throws SAXNotRecognizedException,
                                                  SAXNotSupportedException {
        if (name.equals("http://xml.org/sax/features/namespaces")) {
            return true;
        } else if (name.equals(
                "http://xml.org/sax/features/namespace-prefixes")) {
            return true;
        } else {
            throw new SAXNotRecognizedException(
                "Feature " + name + " not recognized");
        }
    }

    /**
     * Sets the state of a feature.
     *
     *  <p> Recognizes <code>http://xml.org/sax/features/namespaces</code>
     *      and the  <code>http://xml.org/sax/features/namespace-prefixes</code>
     *      feature names.</p>
     *
     * @param  name the feature name, which is a fully-qualified URI.
     * @param  value the requested state of the feature (true or false).
     * @throws org.xml.sax.SAXNotRecognizedException when the XMLReader does not
     *         recognize the feature name.
     * @throws org.xml.sax.SAXNotSupportedException when the XMLReader
     *         recognizes the feature name but cannot set the requested value.
     * @see    #getFeature
     */
    public void setFeature(String name, boolean value)
            throws SAXNotRecognizedException, SAXNotSupportedException {
        if (    name.equals("http://xml.org/sax/features/namespaces") ||
                name.equals("http://xml.org/sax/features/namespace-prefixes")) {
            return; // Ignores, these features are always set.
        } else {
            throw new SAXNotRecognizedException(
                "Feature " + name + " not recognized");
        }
    }

    /**
     * Looks up the value of a property.  
     *
     * @param  name the property name, which is a fully-qualified URI.
     * @return the current value of the property.
     * @throws org.xml.sax.SAXNotRecognizedException when the
     *         XMLReader does not recognize the property name.
     * @throws org.xml.sax.SAXNotSupportedException when the
     *         XMLReader recognizes the property name but
     *         cannot determine its value at this time.
     * @see    #setProperty
     */
    public Object getProperty(String name)
            throws SAXNotRecognizedException, SAXNotSupportedException {
        throw new SAXNotRecognizedException(
             "Property " + name + " not recognized");
    }

    /**
     * Sets the value of a property. 
     * 
     * @param  name the property name, which is a fully-qualified URI.
     * @param  value the requested value for the property.
     * @throws org.xml.sax.SAXNotRecognizedException when the
     *         XMLReader does not recognize the property name.
     * @throws org.xml.sax.SAXNotSupportedException when the
     *         XMLReader recognizes the property name but
     *         cannot set the requested value.
     */
    public void setProperty(String name, Object value)
            throws SAXNotRecognizedException, SAXNotSupportedException {
            throw new SAXNotRecognizedException(
                "Property " + name + " not recognized");
    }

    /**
     * Allows an application to register an entity resolver (ignored by this
     * parser).
     *
     * @param resolver the entity resolver.
     */
    public void setEntityResolver(EntityResolver resolver) {
        _entityResolver = resolver;
    }
    private EntityResolver _entityResolver;

    /**
     * Returns the current entity resolver.
     *
     * @return the current entity resolver, or <code>null</code> if none
     *         has been registered.
     * @see    #setEntityResolver
     */
    public EntityResolver getEntityResolver() {
        return _entityResolver;
    }

    /**
     * Allows an application to register a DTD handler (ignored by this parser).
     *
     * @param handler the DTD handler.
     */
    public void setDTDHandler(DTDHandler handler) {
        _dtdHandler = handler;
    }
    private DTDHandler _dtdHandler;

    /**
     * Returns the current DTD handler.
     *
     * @return the current DTD handler, or <code>null</code> if none
     *         has been registered.
     * @see    #setDTDHandler
     */
    public DTDHandler getDTDHandler() {
        return _dtdHandler;
    }

    /**
     * Throws parsing exception.
     *
     * @param  message the error message.
     * @throws SAXException any SAX exception, possibly wrapping another
     *         exception.
     */
    private void parseError(String message) throws SAXException {
        SAXParseException error = new SAXParseException(message, _locator);
        _errorHandler.fatalError(error);
    }

    /**
     * Returns a new character sequence from the pool.
     *
     * @return a recycled character sequence.
     */
    private CharSequenceImpl newChars() {
        return (_poolIndex < _pool.length) ? _pool[_poolIndex++] : newChars2();
    }
    private CharSequenceImpl newChars2() { // Resizes.
        CharSequenceImpl[] tmp = new CharSequenceImpl[_pool.length * 2];
        System.arraycopy(_pool, 0, tmp, 0, _pool.length);
        for (int i=_pool.length; i < tmp.length; i++) {
            tmp[i] = new CharSequenceImpl();
        }
        _pool = tmp;
        return _pool[_poolIndex++];
    }

    /**
     * Indicates if the specified character sequence is xmlns.
     *
     * @param  chars the characters sequence to be tested.
     * @return <code>chars.equals("xmlns")</code>
     */
    private static boolean isXmlns(CharSequenceImpl chars) {
        return (chars.length == 5) &&
               (chars.data[chars.first]   == 'x') &&
               (chars.data[chars.first+1] == 'm') &&
               (chars.data[chars.first+2] == 'l') &&
               (chars.data[chars.first+3] == 'n') &&
               (chars.data[chars.first+4] == 's');
    }

    /**
     * Inner class implements Locator interface.
     */
    private class LocatorImpl implements Locator {
        public String getPublicId () {
            return null;
        }
        public String getSystemId () {
            return null;
        }
        public int getLineNumber () {
            int column = _columnOffset + _index;
            // Column zero indicates line-break, readjusts.
            return (column != 0) ? _lineNumber : _lineNumber - 1;
        }
        public int getColumnNumber () {
            int column = _columnOffset + _index;
            // Column zero indicates line-break, readjusts.
            return (column != 0) ? column : _lineLength;
        }
    }

    // Implements reusable.
    public void clear() {
        setContentHandler(DEFAULT_HANDLER);
        setErrorHandler(DEFAULT_HANDLER);
    }
}