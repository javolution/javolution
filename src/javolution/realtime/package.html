<body>
<p> Provides real-time {@link javolution.realtime.Context} for higher
    performance and higher predictability of Java bytecode execution.</p>

<h2><a name="OVERVIEW">Overview:</a></h2>

<p> <i><b>J</b>avolution</i> real-time framework provides additional 
    {@link javolution.realtime.Realtime.ObjectSpace objects spaces} other than the heap space;
    such as the "stack" space or the "hold" space. 
    The object space determines when object recycling does occur:
    <UL>
    <LI> Heap : Indirectly recycled through garbage collection when the object is not reachable (default).</LI>
    <LI> Stack : Recycled when the current thread exits the scope of the {@link javolution.realtime.PoolContext PoolContext} where the object has been "factory produced".</LI>
    <LI> Hold : Not recycled. Moved back to its original space when internal {@link javolution.realtime.RealtimeObject#preserve preserve} count drops to zero.</LI>
    </UL>
    Any Java<SUP>TM</SUP> object (or array) can be produced using a static 
    {@link javolution.realtime.ObjectFactory ObjectFactory} and therefore can 
    be pre-allocated (at any appropriate time) and/or stack allocated.</P>

<P> This facility works with any VM or even native executable (GCJ). 
    It is also well suited for <a href="https://rtsj.dev.java.net/">RTSJ</a> VMs
    <UL> 
    <LI> To avoid <b><code>IllegalAssignmentError</code></b>: Stack objects can be 
         {@link javolution.realtime.AllocationProfile preallocated} in heap or immortal memory 
         and be referenced from any other objects. For example:<PRE>
         void main(String[]) {
             // Preallocates factory objects in immortal memory at start-up.
             ImmortalMemory.instance().enter(new Runnable() {
                 public void run() {
                     AllocationProfile.load(); 
                 }
             });
         }</PRE></LI>
    <LI> To avoid <b><code>MemoryAccessError</code></b>: NoHeapRealTimeThread 
         may communicate with other threads through objects in immortal memory
         with <i><b>J</b>avolution</i> doing the recycling (necessary as immortal
         memory is never garbage collected).</LI>
    </UL></P>
    
<P> <i><b>J</b>avolution</i> allows your application to control when the object creation 
    does occur! In other words, even when using the default heap space, you can move object 
    allocation and garbage collection out of your high-performance code 
    (see {@link javolution.realtime.AllocationProfile AllocationProfile}).</P>

<h2><a name="FAQ">FAQ:</a></h2>
<ol>
    <a name="FAQ-0"></a>
    <li><b>I am writing an application using third party libraries. 
          I cannot avoid GC unless I get the source and patch it to Javolution.
          Can I still make my application real-time ?</b>
    <p> 
    If the third party library performs dynamic memory allocations in normal methods (not constructors),
    you might not be able to avoid garbage collection. But you cannot get determinism using 
    "any" third party library anyway, regardless of the garbage collector issue. 
    Array resizing, lazy initialization, map rehashing (...) would all introduce unexpected 
    delays (this is why Javolution comes with its own real-time collection implementation). 
    Still, you have several options:
    <ol>
    <li> Run GC at an appropriate time (<code>System.gc()</code>).</li>
    <li> Use incremental/concurrent collectors.</li>
    <li> Run non-allocating real-time threads or Javolution-Using threads at higher 
         priority than the garbage collector.</li>
    </ol>
    <p></p>
    <p><i> The latest solution works only with non-moving garbage collectors such as the Boehm-Weiser collector
    employed by the <a href="http://www.gnu.org/software/gcc/java/">Gnu Compiler for Java</a>.
    Native compilers (such as the <a href="http://www.gnu.org/software/gcc/java/">GCJ</a>) or 
    Ahead-of-Time compilers are also recommended to avoid JIT compilation interruptions (common with the HotSpot VM).</i></p>
    </li><p></p>

    <a name="FAQ-1"></a>
    <li><b>Can you explain a little how the PoolContext works? 
    I looked at the example code in the Javadoc, and I'm still a little fuzzy on where and what 
    the "magic" is that it performs...</b>
    <p> 
    The basic idea is to associate objects pools to Java threads. 
    These pools can be nested, with the heap being the root of all pools.
    You may consider pools' objects as part of the thread stack memory, with pools being pushed and 
    popped as the thread enters/exits {@link javolution.realtime.PoolContext PoolContext}.
    To allocate from its <b>stack</b>, a thread needs to execute within a pool context
    and create <i>new</i> objects using {@link javolution.realtime.ObjectFactory factories}
    (the "new" keyword always allocates on the heap, Javolution does not/cannot change 
    the Java Virtual Machine behavior). This mechanism is similar to the allocation
    on the stack of locally declared primitive variables, but now extended to
    non-primitive objects.
    </p> 
    <p><i> Classes encapsulating calls to object factories within
                factory methods (e.g. <code>valueOf(...)</code>) and 
                whose methods do not create temporary objects using the "new" keyword
                are known as <b>"real-time compliant"</b>.</i></p>
    </li><p></p>

    <a name="FAQ-2"></a>
    <li><b>How do I make my own classes real-time compliant?</b>
    <p> The simplest way is to extend {@link javolution.realtime.RealtimeObject RealtimeObject}
        and use a factory to create new instances. For example:<pre>
    public static final class Coordinates extends RealtimeObject {
        private double _latitude;
        private double _longitude;        
        private static final Factory&lt;Coordinates&gt; FACTORY = new Factory&lt;Coordinates&gt;() {
              protected Coordinates create() {
                  return new Coordinates();
              }
        };
        private Coordinates() {} 
        public static Coordinates valueOf(double latitude, double longitude) {
            Coordinates c = FACTORY.object();
            c._latitude = latitude;
            c._longitude = longitude;
            return c;
        }
    }</pre>
    Et voila! Your class is now real-time compliant!
    <p> The following code shows the accelerating effect of stack allocations.<pre>
     public static void main(String[] args) {
         Coordinates[] vertices = new Coordinates[1000000];
         for (int i=0; i < 10; i++) {     
             long time = System.currentTimeMillis();
             PoolContext.enter();
             try {
                 for (int j = 0; j < vertices.length; j++) {
                     vertices[j] = Coordinates.valueOf(i, j);
                     // vertices[j] = new Coordinates(i, j); 
                 }
             }finally {
                 PoolContext.exit();
             }
             time = System.currentTimeMillis()-time;
             System.out.println("Time = " + time);
         }
     }</pre>
        The first iteration is slower in this example because {@link javolution.realtime.AllocationProfile preallocation}
        has not been performed (objects are created on demand to populate the stack).<br> 
        Subsequent iterations are not only faster but 
        very consistent in time as no memory allocation/garbage collection 
        will ever occur.<pre> 
   Time = 1359
   Time = 110
   Time = 110
   Time = 110
   Time = 109
   Time = 109
   Time = 110
   Time = 110
   Time = 110
   Time = 110</pre>
    
  <p> The same program allocating directly on the heap (e.g. <code>new Coordinates(i, j)</code>)
     produces the following result:<pre>
   Time = 1140
   Time = 1344
   Time = 1296
   Time = 1282
   Time = 1312
   Time = 1266
   Time = 1312
   Time = 828
   Time = 1313
   Time = 1266</pre> 
  Not only code execution is <b>10x</b> time slower but there is much 
  more fluctuation in the execution time due to GC.</p>
    </li><p></p>
    
    <a name="FAQ-3"></a>
    <li><b>As a rule, I am skeptical of classes that pool small objects. 
     At one time (5 years ago) it was a big win. Over time, the advantage has 
     diminished as garbage collectors improve. Object pools can make it much more
     difficult for the garbage collector to do its job efficiently, and can have
     adverse effects on footprint. (Joshua Bloch) </b>
    <p> Stack allocation is a simple and transparent way to make your methods "clean" (no garbage 
        generated), it has also the side effect of making your methods faster 
        and more time-predictable. If all your methods are "clean" then your whole 
        application is "clean", faster and more time-predictable (aka real-time).</p>
    <p> Applications may use the facility to different degrees. 
        For example, to improve performance one might identify the biggest "garbage producers" 
        and use stack allocations instead of heap allocations for those only. 
        Others might want to run high priority threads in a pool context and
        by avoiding heap allocations (and potential GC wait), make these threads highly deterministic.</p>
    <p> In practice, very few methods declare a pool context for local stack allocations, 
        only the "dirty" ones (the one generating a lot of  garbage). Iterations are often good
        candidates as they typically generate a lot of garbage. For example:<pre>
   public Matrix pow(int exp) {
       PoolContext.enter(); // Starts local stack allocation.
       try { 
           Matrix pow2 = this;
           Matrix result = null;
           while (exp >= 1) { // Iteration.
                if ((exp & 1) == 1) {
                   result = (result == null) ? pow2 : result.times(pow2);
                }
                pow2 = pow2.times(pow2);
                exp >>>= 1;
           } 
           return result.export(); // Exports result to outer stack (or heap).
       } finally {
            PoolContext.exit(); // Resets local stack (all temporary objects recycled at once).
       }
    }</pre></p>
    <P> For the very "dirty" (e.g. very long interations), one pool context
        might not be enough and may cause memory overflow. You might have
        to break down the iteration loop and use inner pool contexts. Also, 
        by using multiple layers of small nested pool contexts instead of a single
        large pool, one keeps the pools' memory footprint very low and still 
        benefits fully from the facility. Pools of a few dozens objects are
        almost as efficient as larger pools. This is because entering/exiting
        pool contexts is fast and the CPU cache is more effective with small pools.</p>
        
    <p>Individual recycling is possible for methods having access 
       to the object pool. It is the case for code declaring {@link javolution.realtime.ObjectFactory factory}
       instances (usually <b>private</b>) or for {@link javolution.realtime.RealtimeObject RealtimeObject} 
       sub-classes through the <b>protected</b> {@link javolution.realtime.RealtimeObject#recycle recycle} method.<pre>
       
    // Use of factory pool access to recycle immediately.
    //
    ObjectPool&lt;char[]&gt; charsPool = CHAR_1024_FACTORY.currentPool();
    char[] buffer = charsPool.next(); // Next object from pool.
    for (int i = reader.read(buffer, 0, buffer.length); i > 0;) {
        ...
    } 
    charsPool.recycle(buffer); // Puts object back into its pool immediatly (optional).
    ...
    private static final ObjectFactory&lt;char[]&gt; CHAR_1024_FACTORY = new ObjectFactory&lt;char[]&gt;() { 
        public char[] create() { return new char[1024]; }
    };
        
    // Use of protected recycle method to recycle immediately.
    //
    public LargeInteger gcd(LargeInteger that) {
        LargeInteger a = this.abs();
        LargeInteger b = that.abs();
        while (!b.isZero()) {
            LargeInteger tmp = a.divide(b);
            LargeInteger c = tmp.getRemainder();
            tmp.recycle(); // Individual recycling affects local objects only 
            a.recycle();   // (no effect on heap objects or outer objects).
            a = b;
            b = c;
        }
        return a;
    }</pre></p>
    </li><p></p>

    <a name="FAQ-4"></a>
    <li><b>Are not PoolContext inherently unsafe (e.g. immutable objects changing
        suddenly values) ?</b>
    <p> No, as long as you {@link javolution.realtime.RealtimeObject#export export} or 
        {@link javolution.realtime.RealtimeObject#preserve preserve} the
        objects which might be referenced outside of the pool context,
        <b>immutable objects stay immutable!</b> Furthermore, you do not have to 
        worry about thread synchronization as stack objects are thread-local.</p>
    <p> In practice, <b>very few</b> methods have to worry about these constraints. 
        They are:</p>
        <ol>
        
        <li><p>The methods with the pool context <b><code>try, finally</code></b> block statement defined. 
            They have to ensure that objects created/modified inside the context scope and 
            accessible outside of the scope are {@link javolution.realtime.RealtimeObject#export exported} 
            (a return value typically).</p></li>
            
        <li><p> The methods creating or modifying <b><code>static</code></b> objects.
            Becauses <code>static</code> objects can be accessed from any thread, local objects 
            need to be {@link javolution.realtime.RealtimeObject#moveHeap moved to the heap}
            or better {@link javolution.realtime.RealtimeObject#preserve preserved} when made accessible
            from a static object (when using preserve, one will have to 
            {@link javolution.realtime.RealtimeObject#unpreserve unpreserved} at a later 
            time, typically when the preserved value is replaced).</i></li>
        </ol>
    <p> For additional safety, <b>IllegalAccessError</b> are raised during execution when  
        the rules above are broken.</p>
    <p> In truth, object spaces promote the use of immutable objects 
        (as their allocation cost is being significantly reduced), reduces thread 
        interaction (e.g. race conditions) and often lead to safer, faster and more
        robust applications.</p>
    </li><p></p>

    <a name="FAQ-5"></a>
    <li><b>Our application is hard real-time, we cannot afford to run GC 
        ever, can we still use Javolution ?</b>
    <p> <b>A resounding Yes!</b> The easiest way is to ensure that all your threads
         run in a pool context, only static constants are exported to 
         the heap and your system state can be updated without allocating new objects.
         This last condition is easily satisfied by using mutable objects or 
         by preventing local (on the stack) immutable objects from being automatically recycled.
         The following illustrates this capability:<pre>

         // This thread recycles its objects itself (very fast).
         class Navigator extends Thread {
             private Coordinates position = Coordinates.valueOf(0, 0);
             public void run() {
                 while (true) {
                     PoolContext.enter();
                     try {
                         Coordinates newPosition = calculatePosition(); // Performed using objects from this pool context.
                         position.unpreserve();                         // Allows old position object to be recycled
                         synchronized (this) {                          
                             position = newPosition.preserve();
                         }    
                     } finally {                     
                         PoolContext.exit();                            // Recycles all stack objects except the position object
                     }                                                  // (very fast, just a stack pointer reset).
                 }
             }
             public synchronized Coordinates getPosition() {            // On the stack of the calling thread.
                 return position.copy();
             }
          }</pre></p>

         <IMG alt="Hard Real-Time Application (no GC ever)" src="doc-files/realtime.jpg">

         <p> Some JDK library classes may create temporary objects on the heap and 
         therefore should be avoided or replaced by "cleaner" classes 
         (e.g. {@link javolution.util.FastMap FastMap} instead of <code>java.lang.HashMap</code>,
         {@link javolution.lang.TextBuilder TextBuilder} instead of <code>java.lang.StringBuffer</code> 
         (<code>setLength(0)</code> allocates a new internal array) and
         {@link javolution.lang.TypeFormat TypeFormat} for parsing/formatting of primitive types).</p>
    </li><p></p>

    <a name="FAQ-6"></a>
    <li><b>What performance gain can I expect by using a pool context?</b>
    <p> Classes avoiding dynamic memory allocation are significantly faster.
        For example, our {@link javolution.xml.sax.XmlSaxParserImpl XmlSaxParserImpl} and 
        {@link javolution.xml.pull.XmlPullParserImpl XmlPullParserImpl} 
        are <b>3-5x</b> faster than any conventional xml parsers. To avoid synchronization 
        issues, it is often easier to allocate new objects. Other techniques such 
        as the "returnValue" parameter are particularly ugly and unsafe
        as they require mutability. Javolution's real-time facility promotes the dynamic 
        creation of immutable objects as these object creations are fast and have no adverse
        effect on garbage collection. Basically, with pool contexts, <b> the CPU is 
        busy doing the "real thing" not "memory management"!</b></p>
    <p> The cost of allocating on the heap is somewhat <b>proportional
        to the size</b> of the object being allocated. By avoiding or postponing this
        cost you can drastically increase the execution speed.<b> The largest objects
        benefit the most.</b> For example, adding <code>LargeInteger</code> in a pool context
        is at least <a href="http://jscience.org/doc/benchmark.html"><b>6x</b> faster</a> than adding 
        <code>java.math.BigInteger</code>,
        our {@link javolution.lang.Text Text} class
        can be <a href="http://javolution.org/doc/benchmark.html"><b>several orders of magnitude faster</b></a>
        than <code>java.lang.String</code>.
        Not surprising when you know that even "empty" <code>Strings</code> 
        take 40 bytes of memory which have to be initialized and garbage collected!</p>
    <p> Recycling objects is always more efficient than just recycling memory (aka GC).
        Our {@link javolution.util.FastMap FastMap} is 
        a complex object using preallocated linked lists. It is fast but costly
        to build. Nevertheless, in a pool context it can be used as a throw-away map
        because <b>the construction cost is then reduced to nothing!</b></p>
    </li><p></p>

    <a name="FAQ-7"></a>
    <li><b>Virtual Machines with concurrent garbage collection are becoming more
           and more popular. Do we still need a real-time facility?</b>
    <p> Concurrent garbage collection is the perfect complement to <i><b>J</b>avolution</i> real-time facility.
        For example, with a real-time garbage collector, preallocation can be performed by a background thread 
        making sure that objects are ready when the application needs them. It should be noted that 
        even with an infinitely fast garbage collector, applications using <i><b>J</b>avolution</i> will
        always be faster because they do not have to go through the object creation/initialization/setup 
        process for each new object.</p>
        
    <p> For real-time virtual machines, the advantages of the facility are threefold:
    
        <ul><li> Faster execution. Objects have already been allocated, initialized 
                 and are more likely to be in the CPU cache <b>(increases responsiveness)</b>.</li>
                 
            <li> By limiting/eliminating garbage (pool contexts), we ensure that a concurrent collector
                 can always keep up with the garbage flow and avoid a stop-the-world collection
                 situation (a disaster for real-time system). Furthermore, the 
                 collector total CPU usage can be significantly reduced <b>(maximizes processing efficiency)</b>.</li>
                 
            <li> Easy integration of the RTSJ <code>NoHeapRealTimeThread</code> with other threads 
                 by having shared objects in immortal memory and <i><b>J</b>avolution</i> 
                 doing the recycling (necessary as immortal memory is never garbage collected).</li>
        </ul></p>
    </li><p></p>
    <a name="FAQ-8"></a>
    <li><b>Could you show us practical examples?</b>
    <p> Sure, here is a code excerpt from a developer working on genetic algorithms:
    <pre>
    public static void main(String[] args) {
        FastList&lt;Amoeba&gt; population = new FastList&lt;Amoeba&gt;();
        FastTable&lt;Amoeba&gt; survivors = new FastTable&lt;Amoeba&gt;();
        for (int i = 0; i < POPULATION_SIZE; i++) {
            population.add(Amoeba.newInstance());
        }
        while (...) {
            PoolContext.enter();
            try {
                for (FastList.Node&lt;Amoeba&gt; n = population.headNode(), end = population.tailNode(); (n = n.getNextNode()) != end;) {
                    Amoeba a = n.getValue();
                    if (a.getSurvivalLevel() >= average) {
                        survivors.add(a);
                    } else {
                        a.unpreserve(); // Allows recycling.
                    }
                }
                population.clear();
                population.addAll(survivors); 
                for (int i = population.size(); i < POPULATION_SIZE; i++) {
                    Amoeba male = survivors.get(MathLib.randomInt(0, survivors.size()-1));
                    Amoeba female = survivors.get(MathLib.randomInt(0, survivors.size()-1));
                    population.add(PairingUtil.pair(male, female).preserve()); // New amoeba allocated on the stack but preserved!
                }
                survivors.clear();
                generation++;
            } finally { // Recycles all stack objects except for the current amoeba population.
                PoolContext.exit(); // Recycles.
            }
        }
    }
    ...
    public int getSurvivalLevel() {
        ObjectPool&lt;int[][]&gt; boardPool = BOARD_FACTORY.currentPool();  
        int[][] board = boardPool.next(); // Returns thread-local board.
        ... // Do some complicate stuff with the board (board game ?)
        int level = 0;
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                level += board[i][j];
            }
        }
        boardPool.recycle(board); // Immediate recycling.
        return level;
    }
    private static ObjectFactory&lt;int[][]&gt; BOARD_FACTORY = new ObjectFactory&lt;int[][]&gt;() { 
        protected int[][] create() {
            return new int[8][8];
        }
    };</pre>
    <em><b>The same code without using pool context is several times slower!</b></em></p>

</ol>
<h2><a name="CONCLUSION">Conclusion:</a></h2>
        Soft/Hard Real-Time applications can significantly benefit
        from this (small) package. It would be nice if it came standard with the Java library.
        Direct JVM support of thread-local stacks and making the <i>new</i> keyword context sensitive
        would make Java more powerful, deterministic and execute faster!
        This changes would be backward compatible as the default context for normal threads
        is the heap context.<br>
</body>