<body>
<p> Provides real-time {@link javolution.context.Context} for higher
    performance and higher predictability of Java bytecode execution.</p>

<h2><a name="OVERVIEW">Overview:</a></h2>

<p> This package provides thread-local {@link javolution.context.Context contexts} 
    integrated with the Real-Time Specification for Java 
    (<a href="https://rtsj.dev.java.net/">RTSJ</a>). They can be used 
    to significantly decrease the "worst-case" execution time, 
    leverage most of RTSJ capabilities and reduce/eliminate the need for object
    creation and garbage collection.</p>
<ol>
    <li><h3>Reducing "worst-case" execution time.</h3>
    There are many factors impacting the "worst-case" execution time among them 
    just-in-time compilation, garbage collection, class initialization
    (see <a href="http://javolution.org/doc/Man33955.pdf">"Validating Java for Safety
    Critical Applications"</a> for an overview). Unexpected 
    delays can be reduced through Ahead-Of-Time compilation,  Realtime/Incremental Garbage Collection, 
    {@link javolution.lang.ClassInitializer ClassInitializer} and time-deterministic 
    {@link javolution.util collections} classes.
    Still, the first time an operation is performed is often the "worst-case" time 
    because of the initial objects creation which occurs then.
    To address this issue, <i><b>J</b>avolution</i> allows thread-local contexts
    to be serialized/deserialized and loaded at start-up. Then, applications threads 
    have consistent, fast performance from start to end! For example:[code]
    public class MyPeriodicThread extends NoHeapRealtimeThread {
        // Retrieves pool context "sized" from previous execution profile. 
        InputStream in = MyPeriodicThread.class.getResourceAsStream("/pool-" + getName() + ".xml");
        PoolContext pool = (in != null) ? XMLObjectReader.newInstance(in).read() : new PoolContext();
        public void run() {
            while (!terminate) {
                Context.enter(pool);
                try {
                    ... // Consistently fast, factory-produced objects have already been created.
                } finally {
                    Context.exit(pool); // Recycles all pool objects to the exception of the ones preserved.
                }
                RealtimeThread.waitForNextPeriod();
            }
            // Saves pool context (optional).
            OutputStream out = new FileOutputStream("bin/pool-" + getName() + ".xml");
            XMLObjectWriter writer = XMLObjectWriter.newInstance(out);
            writer.write(pool);
            writer.close();
        }
    }[/code]
    <i> Note: Worst case execution time can be decreased even further by using
        {@link javolution.context.PersistentContext.Reference PersistentContext.Reference}
        to hold global data time consuming to regenerate.</i></li>
         
    <li><h3> Leveraging RTSJ capabilities.</h3>
    The <i><b>J</b>avolution</i> library is the first library to be fully RTSJ compliant.
    For example, if the capacity of a collection increases, the extension part is allocated 
    from the same memory area as the collection itself (regardless of the current memory area).
    {@link javolution.lang.Reusable Reusable} can be <code>static</code> 
    (allocated in <code>ImmortalMemory</code>) and safely used by any real-time threads. 
    Similarly, contexts can be allocated in a specific memory area and their behavior is not affected 
    by the current thread execution area. In other words, <code>NoHeapRealTimeThread</code>
    may run in <code>ScopedMemory</code> and create (through factories) persistent objects from
    a {@link javolution.context.PoolContext PoolContext} in <code>ImmortalMemory</code> with 
    <i><b>J</b>avolution</i> doing the recycling 
    (necessary as <code>ImmortalMemory</code> is never garbage collected).<br>
    It should be noted that the standard Java library is not RTSJ-Safe and its use 
    is likely to result in run-time errors or memory leaks with RTSJ VMs (see collection classes 
    <a href="http://javolution.org/doc/Javolution-Collections.pdf">presentation</a>).
    The following illustrates a typical problem with <code>static</code> class members
    (automatically allocated in ImmortalMemory with RTSJ VMs):[code]
    public class XmlFormat {
        // RTSJ Unsafe! Memory leaks (when entries removed) or IllegalAssignmentError (when new entries while in ScopedArea).   
        static HashMap<Class, XmlFormat> ClassToFormat = HashMap<Class, XmlFormat>();
        
       // RTSJ Safe! Removed entries are internally recycled, new entries are in ImmortalMemory.
       static FastMap<Class, XmlFormat> ClassToFormat = FastMap<Class, XmlFormat>();
   }[/code]    
    </li>

    <li><h3> Reducing Object Creation / Garbage Collection.</h3>
    The cost of allocating large objects (or arrays) is still significant 
    (memory has to be allocated, initialized and later garbage collected). 
    This cost is somewhat proportional to the size of the object being allocated.
    To drastically increase the execution speed, applications may create new objects  
    through {@link javolution.context.ObjectFactory factories} and allow for transparent object recycling 
    and/or pre-allocation at start-up.</li>
</ol>
    
<h2><a name="UML">UML Diagram:</a></h2>

<IMG alt="Realtime Package - UML Diagram" src="doc-files/realtime_uml.png">


<h2><a name="FAQ">FAQ:</a></h2>
<ol>
    <a name="FAQ-0"></a>
    <li><b>I am writing an application using third party libraries. 
          I cannot avoid GC unless I get the source and patch it to Javolution.
          Can I still make my application real-time ?</b>
    <p> 
    You cannot get determinism using "any" library (including Java standard library) 
    regardless of the garbage collector issue. Array resizing, lazy initialization, map rehashing (...)
    would all introduce unexpected  delays (this is why Javolution comes with its own real-time collection
    implementation). Still, you have several options:
    <ul>
    <li> Use incremental/real-time collectors (if few milliseconds delays are acceptable).
         These collectors work faster if you limit the amount of garbage produced 
         (e.g. using pool contexts).</li>
    <li> Run your real-time code using a <code>NoHeapRealtimeThread</code> at higher priority than 
         the garbage collector. This may require using pool contexts in <code>ImmortalMemory</code> 
         for persistency (as <code>ScopedArea</code> can only be used for temporary objects).</li>
    </ul>
    <p></p>

    <a name="FAQ-1"></a>
    <li><b>Can you explain a little how the PoolContext works? 
    I looked at the example code in the Javadoc, and I'm still a little fuzzy on where and what 
    the "magic" is that it performs...</b>
    <p> 
    The basic idea is to associate objects pools to Java threads. 
    These pools can be nested, with the heap being the root of all pools.
    You may consider pools' objects as part of the thread stack memory, with pools being pushed and 
    popped as the thread enters/exits {@link javolution.context.PoolContext PoolContext}.
    To allocate from its <b>stack</b>, a thread needs to execute within a pool context
    and create <i>new</i> objects using {@link javolution.context.ObjectFactory factories}
    (the "new" keyword always allocates on the heap, Javolution does not/cannot change 
    the Java Virtual Machine behavior). This mechanism is similar to the allocation
    on the stack of locally declared primitive variables, but now extended to
    non-primitive types.
    </p> 
    <p><i> Classes encapsulating calls to object factories within
                factory methods (e.g. <code>valueOf(...)</code>) and 
                whose methods do not create temporary objects on the heap
                are known as <b>"real-time compliant"</b>.</i></p>
    </li><p></p>

    <a name="FAQ-2"></a>
    <li><b>How do I make my own classes real-time compliant?</b>
    <p> The simplest way is to extend {@link javolution.context.RealtimeObject RealtimeObject}
        and use a factory to create new instances. For example:[code]
    public static final class Coordinates extends RealtimeObject {
        private double _latitude;
        private double _longitude;        
        private static final Factory<Coordinates> FACTORY = new Factory<Coordinates>() {
              protected Coordinates create() {
                  return new Coordinates();
              }
        };
        public Coordinates(double latitude, double longitude) {
            _latitude = latitude;
            _longitude = longitude;
        } 
        private Coordinates() {} 
        public static Coordinates valueOf(double latitude, double longitude) {
            Coordinates c = FACTORY.object();
            c._latitude = latitude;
            c._longitude = longitude;
            return c;
        }
    }[/code]
    Et voila! Your class is now real-time compliant!
    <p> The following code shows the accelerating effect of stack allocations.[code]
     public static void main(String[] args) {
        ClassInitializer.initialize(PoolContext.class); // To avoid measuring class initialization time.
        Coordinates[] vertices = new Coordinates[100000];
        for (int i=0; i < 10; i++) {     
            long time = System.nanoTime();
            PoolContext.enter();
            try {
                for (int j = 0; j < vertices.length; j++) {
                    vertices[j] = Coordinates.valueOf(i, j);
                    //vertices[j] = new Coordinates(i, j); 
                }
            }finally {
                PoolContext.exit();
            }
            time = System.nanoTime()-time;
            System.out.println("Time = " + time / 1E6);
         }
     }[/code]
        The first iteration is slower in this example because the pool context has not be loaded
        at start-up (any context can be serialized/deserialized) and most objects are created 
        during the first iteration.<br> Subsequent iterations are not only faster but 
        very consistent in time as no memory allocation/garbage collection 
        will ever occur.<pre> 
Time = 36.576713
Time = 10.310808
Time = 10.024459
Time = 10.228395
Time = 10.078376
Time = 10.298236
Time = 10.480103
Time = 10.081449
Time = 10.236496
Time = 10.247391</pre>
    
  <p> The same program allocating directly on the heap (e.g. <code>new Coordinates(i, j)</code>)
     produces the following result:<pre>
Time = 27.496512
Time = 13.557868
Time = 12.621716
Time = 51.020451
Time = 9.327443
Time = 8.798604
Time = 23.881527
Time = 8.829055
Time = 60.977303
Time = 7.708242</pre> 
  As you can see there is much more fluctuation in execution time due to 
  garbage collections interferences (making the average time several times greater).</p>
    </li><p></p>
    
    <a name="FAQ-3"></a>
    <li><b>As a rule, I am skeptical of classes that pool small objects. 
     At one time (5 years ago) it was a big win. Over time, the advantage has 
     diminished as garbage collectors improve. Object pools can make it much more
     difficult for the garbage collector to do its job efficiently, and can have
     adverse effects on footprint. (Joshua Bloch) </b>
    <p> Stack allocation is a simple and transparent way to make your methods "clean" (no garbage 
        generated), it has also the side effect of making your methods faster 
        and more time-predictable. If all your methods are "clean" then your whole 
        application is "clean", faster and more time-predictable (aka real-time).</p>
    <p> Not all VMs are created equals. The speed and real-time characteristics 
        for object creation/garbage collection may vary significantly. By using 
        stack allocation you ensure consistent behavior regardless of the client vm.</p>
    <p> Applications may use the facility to different degrees. 
        For example, to improve performance one might identify the biggest "garbage producers" 
        and use stack allocations instead of heap allocations for those only. 
        Others might want to run high priority threads in a pool context and
        by avoiding heap allocations (and potential GC wait), make these threads highly deterministic.</p>
    <p> In practice, very few methods declare a pool context for local stack allocations, 
        only the "dirty" ones (the one generating a lot of  garbage). Iterations are often good
        candidates as they typically generate a lot of garbage. For example:[code]
   public Matrix pow(int exp) {
       PoolContext.enter(); // Starts local stack allocation.
       try { 
           Matrix pow2 = this;
           Matrix result = null;
           while (exp >= 1) { // Iteration.
                if ((exp & 1) == 1) {
                   result = (result == null) ? pow2 : result.times(pow2);
                }
                pow2 = pow2.times(pow2);
                exp >>>= 1;
           } 
           return result.export(); // Exports result to outer stack (or heap).
       } finally {
            PoolContext.exit(); // Resets local stack (all temporary objects recycled at once).
       }
    }[/code]</p>
    <P> For the very "dirty" (e.g. very long interations), one pool context
        might not be enough and may cause memory overflow. You might have
        to break down the iteration loop and use inner pool contexts. Also, 
        by using multiple layers of small nested pool contexts instead of a single
        large pool, one keeps the pools' memory footprint very low and still 
        benefits fully from the facility. Pools of a few dozens objects are
        almost as efficient as larger pools. This is because entering/exiting
        pool contexts is fast and the CPU cache is more effective with small pools.</p>
        
    <p> Immediate recycling is possible for methods having access to the object factory
        (implementation code as factories are typically private). Immediate recycling
        is a very efficient way of recycling intermediate/temporary objects not referenced anymore. For example:[code]
        
    // Immediate recycling of primitive types wrappers.
    //
    class StringToInt extends FastMap<String, Int32> {
        void put(String key, int value) {
            Int32 int32 = Int32.FACTORY.object();
            int32.value = value;
            Int32 previous = put(key, int32); // Previous primitive wrapper is not referenced any more.
            if (previous != null) Int32.FACTORY.recycle(previous); 
        }
    }
    class Int32 extends RealtimeObject { ... } // RealtimeObject have faster immediate recycling.
       
    // Immediate recycling of temporary buffer.
    //
    char[] buffer = CHAR_1024_FACTORY.object(); // Potentially recycled instance.
    for (int i = reader.read(buffer, 0, buffer.length); i > 0;) {
        ...
    } 
    CHAR_1024_FACTORY.recycle(buffer); // Recycles the buffer (thread-local).
    ...
    private static final ObjectFactory<char[]> CHAR_1024_FACTORY = new ObjectFactory<char[]>() { 
        protected char[] create() { return new char[1024]; }
    };
        
    // Immediate recycling of temporary variables.
    //
    public class LargeInteger extends RealtimeObject {
        private static Factory<LargeInteger> FACTORY = new Factory<LargeInteger>() {...};
        ...
        public LargeInteger gcd(LargeInteger that) {
            LargeInteger a = this.abs();
            LargeInteger b = that.abs();
            while (!b.isZero()) {
                LargeInteger tmp = a.divide(b); // Returns always a new object.
                LargeInteger c = tmp.getRemainder();
                FACTORY.recycle(tmp); // Immediate recycling.
                if ((a != this) && (a != that) && // a is not a current input,
                        (a != b) && (a != c)) // nor a persistent object,
                    FACTORY.recycle(a); // it is then safe to recycle.
                a = b;
                b = c;
            }
            return a;
        }
    }[/code]</p>
    </li><p></p>

    <a name="FAQ-4"></a>
    <li><b>Are not PoolContext inherently unsafe (e.g. immutable objects changing
        suddenly values) ?</b>
    <p> No, as long as you {@link javolution.context.RealtimeObject#export export} or 
        {@link javolution.context.RealtimeObject#preserve preserve} the
        objects which might be referenced outside of the pool context,
        <b>immutable objects stay immutable!</b> Furthermore, you do not have to 
        worry about thread synchronization as stack objects are thread-local.</p>
    <p> In practice, <b>very few</b> methods have to worry about these constraints. 
        They are:</p>
        <ol>       
        <li><p>The methods with the pool context <b><code>try, finally</code></b> block statement defined. 
            They have to ensure that objects created/modified inside the context scope and 
            accessible outside of the scope are {@link javolution.context.RealtimeObject#export exported} 
            (a return value typically).</p></li>
            
        <li><p> The methods creating or modifying <b><code>static</code></b> objects.
            Becauses <code>static</code> objects can be accessed from any thread, local objects 
            need to be {@link javolution.context.RealtimeObject#moveHeap moved to the heap}
            or better {@link javolution.context.RealtimeObject#preserve preserved} when made accessible
            from a static object (when using preserve, one will have to 
            {@link javolution.context.RealtimeObject#unpreserve unpreserve} at a later 
            time, typically when the preserved value is replaced).</i></li>
        </ol>
    <p> For additional safety, <b>IllegalAccessError</b> are raised during execution when  
        the rules above are broken.</p>
    <p> In truth, object spaces promote the use of immutable objects 
        (as their allocation cost is being significantly reduced), reduces thread 
        interaction (e.g. race conditions) and often lead to safer, faster and more
        robust applications.</p>
    </li><p></p>

    <a name="FAQ-5"></a>
    <li><b>Our application is hard real-time, we cannot afford to run GC 
        ever, can we still use Javolution ?</b>
    <p> <b>A resounding Yes!</b> The easiest way is to ensure that all your threads
         run in a pool context, only static constants are exported to 
         the heap and your system state can be updated without allocating new objects.
         This last condition is easily satisfied by using mutable objects or 
         by preventing local (on the stack) immutable objects from being automatically recycled.
         The following illustrates this capability:[code]

         // This thread recycles its objects itself (very fast).
         class Navigator extends RealtimeThread {
             private Coordinates position = Coordinates.valueOf(0, 0);
             public void run() {
                 while (true) {
                     PoolContext.enter();
                     try {
                         Coordinates newPosition = calculatePosition();  // On the stack.
                         newPosition.preserve(); // Prevents recycling of the new position.
                         position.unpreserve(); // Ensures recycling of the old position (upon context exit).
                         synchronized (this) { // Updates position.
                             position = newPosition;
                         } 
                     } finally {                     
                         PoolContext.exit();  // Recycles all stack objects except the new position
                     }                        // (very fast, just a stack pointer reset).
                 }
             }
             public synchronized Coordinates getPosition() { // Returns a copy of the position on the stack of the calling thread.
                 return position.copy();
             }
          }[/code]</p>

         <IMG alt="Hard Real-Time Application (no GC ever)" src="doc-files/realtime.jpg">

         <p> Some JDK library classes may create temporary objects on the heap and 
         therefore should be avoided or replaced by "cleaner" classes 
         (e.g. {@link javolution.util.FastMap FastMap} instead of <code>java.lang.HashMap</code>,
         {@link javolution.text.TextBuilder TextBuilder} instead of <code>java.lang.StringBuffer</code> 
         (<code>setLength(0)</code> allocates a new internal array) and
         {@link javolution.text.TypeFormat TypeFormat} for parsing/formatting of primitive types).</p>
    </li><p></p>

    <a name="FAQ-6"></a>
    <li><b>What performance gain can I expect by using a pool context?</b>
    <p> The more temporary objects you generate and the larger these objects,
        the more beneficial are pool contexts. For example, the multiplication of 
        complex matrices (<code>Matrix&lt;Complex&gt;) is several times faster 
        when using pool context (allocating / collecting complex numbers
        in large quantities stresses the garbage collector to the point that 
        performance degrades significantly). By using pool contexts the
        memory footprint (heap usage) is decreased significantly and <b> the CPU is 
        busy doing the "real thing" not "memory management"!</b></p>
    <p> Recycling thread-local objects is often more efficient than just recycling memory (aka GC).
        Our {@link javolution.util.FastMap FastMap} is a complex object using preallocated
        linked lists. It is fast but costly to build. Nevertheless, in a pool context it
        can be used as a throw-away map because <b>the construction cost is then reduced to nothing!</b></p>
    </li><p></p>

    <a name="FAQ-7"></a>
    <li><b>Virtual Machines with real-time garbage collection are becoming more
           and more popular. Do we still need object recycling?</b>
    <p> The major issue with real-time applications is to ensure a minimal "worst-case" execution time.
        Avoiding unwanted pauses (GC or Just-In-Time compilation) is necessary but not sufficient.
        Object creation is still time consuming for large objects. By allowing object
        creation to occur at start-up for reuse latter, the "worst-case" execution time can be 
        considerably reduced.</p>
        
    </li><p></p>

    <a name="FAQ-8"></a>
    <li><b>Could you show us practical examples?</b>
    <p> Sure, here is a code excerpt from a developer working on genetic algorithms:[code]
    public static void main(String[] args) {
        FastTable<Amoeba> population = new FastTable<Amoeba>();
        FastTable<Amoeba> survivors  = new FastTable<Amoeba>();
        for (int i = 0; i < POPULATION_SIZE; i++) {
            population.add(Amoeba.newInstance()); // Initial population.
        }
        while (...) {
            PoolContext.enter();
            try {
                double average = averageFor(population);
                for (int i=0; i < POPULATION_SIZE; i++) {
                    Amoeba a = population.get(i);
                    if (a.getSurvivalLevel() >= average) {
                        survivors.add(a);
                    } else {
                        a.unpreserve(); // Will be recycled.
                    }
                }
                population.clear();
                population.addAll(survivors); 
                for (int i = population.size(); i < POPULATION_SIZE; i++) {
                    Amoeba male = survivors.get(MathLib.randomInt(0, survivors.size()-1));
                    Amoeba female = survivors.get(MathLib.randomInt(0, survivors.size()-1));
                    population.add(pair(male, female).preserve()); // New amoeba allocated on the stack but preserved!
                }
                survivors.clear();
                generation++;
            } finally {
                PoolContext.exit(); // Recycles stack objects (instantaneous).
            }
        }
    }[/code]
    <em><b>The same code without pool context is several times slower (due to numerous amibeas  
    objects created and garbage collected for each generation)!</b></em></p>
    </p>
    </li><p></p>
</ol>
</body>