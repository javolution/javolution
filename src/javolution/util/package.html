<BODY>
<P> Provides high-performance collection classes and miscellaneous utilities; although 
    this package provides very few collection classes, they are substitutes for
    most of <code>java.util.*</code> classes (for example, <code>java.util.IdentityHashMap</code> would be 
    a {@link javolution.util.FastMap FastMap} with an {@link javolution.util.FastComparator#IDENTITY
    identity} key comparator).</P>

<P> Javolution collections are compliant with standard collections (generic when built with the ant target <code>1.5</code>).</P>

<P> They support direct iterations with the following advantages:
    <UL>
    <LI>Faster than iterators, see <A href="http://javolution.org/doc/benchmark.html">benchmark</A>.</LI>
    <LI>No object creation not even the iterator object itself. For example, visiting a tree structure using
        iterators creates as many iterators as they are nodes in the tree:<pre>
        public static void visit(Collection&lt;Collection&gt; node) {
            for (Collection&lt;Collection&gt; i : node) { // Creates iterator.
                visit(i);
            }
        }</pre>
        Not so with direct iterations:<pre>
        public static void visit(FastCollection&lt;FastCollection&gt; node) {
            for (FastCollection.Record r = node.headRecord(), end = node.tailRecord();
                    (r = r.getNextRecord()) != end;) {
                visit(node.valueOf(r));
            }
        }</pre></LI>
    <LI>Used to implement most of {@link javolution.util.FastCollection FastCollection} base class methods 
        (including {@link javolution.util.FastCollection#iterator iterator()}.</LI>
    <LI>Support forward/backward iterations from the start (head) or from the end (tail)</LI>
    <LI>Thread-Safe as long as the record sequence iterated over is not modified by another thread
       (objects can safely be append/prepend by other threads during iteration but not inserted/removed).</LI>
    <LI>Fully integrated with the JDK1.5+ generic framework (strong typing) and still compatible 
        with other platforms (J2ME, 1.4, GCJ).</LI>
    </UL>
    Here are few examples of direct iterations:<pre>
        FastList&lt;String&gt; list = new FastList&lt;String&gt;();
        for (FastList.Node&lt;String&gt; n = list.headNode(), end = list.tailNode(); (n = n.getNextNode()) != end;) {
             String value = n.getValue(); // No typecast necessary.    
        }
        ...
        FastMap map = new FastMap&lt;String, Thread&gt;();
        for (FastMap.Entry&lt;String, Thread&gt; e = map.headEntry(), end = map.tailEntry(); (e = e.getNextEntry()) != end;) {
             String key = e.getKey(); // No typecast necessary.
             Thread value = e.getValue(); // No typecast necessary.
        }
        ...
        FastCollection&lt;Thread&gt; threads ...
        // Removes all dead threads (always iterate from the tail when removing record from an unknown FastCollection, see {@link javolution.util.FastCollection#delete delete}).
        for (FastCollection.Record&lt;Thread&gt; head = threads.headRecord(), r = tailRecord().getPreviousRecord(), previous; r != head; r = previous) {
             previous = r.getPreviousRecord(); // Saves previous.
             if (!threads.valueOf(r).isAlive()) { // No typecast necessary.
                 threads.delete(r);
             }    
        }</pre></P>

<P> Users may provide a read-only view of any {@link javolution.util.FastCollection FastCollection} 
    (or {@link javolution.util.FastMap FastMap}) instance using the 
    {@link javolution.util.FastCollection#unmodifiable() FastCollection.unmodifiable()}
    (or {@link javolution.util.FastMap#unmodifiable FastMap.unmodifiable()}) method.
     For example:<pre>
       public class Unit { // Immutable and unique.
       
          private static final FastSet&lt;Unit&gt; UNITS = new FastSet&lt;Unit&gt;();

          // Read-only view (also thread-safe as units are never "deleted")
          public static FastCollection&lt;Unit&gt; getInstances() { 
              return UNITS.unmodifiable();
          }
      }</pre></P>

<P> Javolution collection classes support concurrent access without synchronization as long as the
    records are not removed (e.g. {@link javolution.util.FastMap FastMap} look-up table) and not
    inserted at arbitrary position (appending to the end of the collection is fine).
    To keep read access unsynchronized when records are deleted, applications may either replace 
    the whole collection/map or better set the record value to <code>null</code> instead of removing it.
    Structural modifications (including appending) should always be synchronized. For example:<pre>
        public class XmlFormat {
             
             static final FastMap&lt;Class, XmlFormat&gt; CLASS_TO_FORMAT = new FastMap&lt;Class, XmlFormat&gt;();
             
             public static XmlFormat getInstance(Class forClass) {
                 return CLASS_TO_FORMAT.get(forClass); // Unsynchronized read.
             }
             
             public void setClass(Class clazz) {
                 synchronized (CLASS_TO_FORMAT) {      // Synchronized update.
                     CLASS_TO_FORMAT.put(clazz, this);
                 }
             } 
        }</pre></P>

<P>  Although all collections capacity increases smoothly (no resizing/copy or rehashing ever performed),
     it is nevertheless possible to specify an initial capacity; in which case, <b>no dynamic 
     memory allocation is ever performed</b> as long as the collection size does not exceeds the specified 
     capacity and regardless of the operation being performed (e.g. lazy initialization is prohibited)! 
     This particularity allows <a href="http://www.rtj.org/">RTSJ</a> applications to allocate
     collections in immortal memory and make them accessible by all threads (including <code>NoHeapRealtimeThread</code>)</P>
     Here is a summary of the collection classes with their defining characteristics:
       <TABLE border="1" summary="Fast Collections Classes">
            <CAPTION><EM><B>Javolution Collections Classes</B></EM></CAPTION>
            <TR>
              <TD></TD>
              <TD><B>Ordering</B></TD>
              <TD><B>Duplication Allowed</B></TD>
              <TD><B>Custom Comparators</B></TD>
              <TD><B>Record Type</B></TD>
              <TD><B>Miscellaneous</B></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastTable FastTable}</TD>
              <TD>Insertion Order</TD>
              <TD>Yes</TD>
              <TD>{@link javolution.util.FastCollection#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastTable.Index Index}</TD>
              <TD>Thread-safe random access collection<BR>
                  No array resize/copy ever performed</TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastList FastList}</TD>
              <TD>Insertion Order</TD>
              <TD>Yes</TD>
              <TD>{@link javolution.util.FastCollection#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastList.Node Node}</TD>
              <TD>Reusable linked-list (recycles its nodes)</TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastSet FastSet}</TD>
              <TD>Insertion Order</TD>
              <TD>No</TD>
              <TD>{@link javolution.util.FastList#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastCollection.Record Record}</TD>
              <TD>Based on {@link javolution.util.FastSet FastMap} (same characteristics)</TD>
            </TR>
            <TR>
              <TD><CODE>FastTree</CODE></TD>
              <TD>Comparator</TD>
              <TD>No</TD>
              <TD><CODE>setValueComparator(FastComparator)</CODE></TD>
              <TD><CODE>TreeNode</CODE></TD>
              <TD><I>(not implemented)</I></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastMap FastMap}</TD>
              <TD>Insertion Order</TD>
              <TD>Key: No<BR>Value: Yes</TD>
              <TD>{@link javolution.util.FastMap#setKeyComparator setKeyComparator(FastComparator)}<BR>
                  {@link javolution.util.FastMap#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastMap.Entry Entry}</TD>
              <TD>Thread-safe access without synchronization if the keys are not removed (e.g. look-up table)<BR>
                  No rehash/resize ever performed <BR>
                  Reusable hash map (recycles its entries)</TD>
            </TR>
         </TABLE>
    </P>    
</BODY>